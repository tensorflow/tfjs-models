{"dependencies":[{"name":"/Users/Shoshana/Documents/Active/2018/Coding_Bootcamp/SeniorPhase/tfjs-models/posenet/demos/package.json","includedInParent":true,"mtime":1533242702575},{"name":"/Users/Shoshana/Documents/Active/2018/Coding_Bootcamp/SeniorPhase/tfjs-models/posenet/demos/.babelrc","includedInParent":true,"mtime":1533242702523},{"name":"/Users/Shoshana/Documents/Active/2018/Coding_Bootcamp/SeniorPhase/tfjs-models/posenet/demos/node_modules/@tensorflow-models/posenet/package.json","includedInParent":true,"mtime":1533242740778},{"name":"../keypoints","loc":{"line":1,"column":46}},{"name":"./util","loc":{"line":3,"column":43}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.decodePose = decodePose;\n\nvar _keypoints = require('../keypoints');\n\nvar _util = require('./util');\n\nvar parentChildrenTuples = _keypoints.poseChain.map(function (_a) {\n    var parentJoinName = _a[0],\n        childJoinName = _a[1];\n    return [_keypoints.partIds[parentJoinName], _keypoints.partIds[childJoinName]];\n});\nvar parentToChildEdges = parentChildrenTuples.map(function (_a) {\n    var childJointId = _a[1];\n    return childJointId;\n});\nvar childToParentEdges = parentChildrenTuples.map(function (_a) {\n    var parentJointId = _a[0];\n    return parentJointId;\n});\nfunction getDisplacement(edgeId, point, displacements) {\n    var numEdges = displacements.shape[2] / 2;\n    return {\n        y: displacements.get(point.y, point.x, edgeId),\n        x: displacements.get(point.y, point.x, numEdges + edgeId)\n    };\n}\nfunction getStridedIndexNearPoint(point, outputStride, height, width) {\n    return {\n        y: (0, _util.clamp)(Math.round(point.y / outputStride), 0, height - 1),\n        x: (0, _util.clamp)(Math.round(point.x / outputStride), 0, width - 1)\n    };\n}\nfunction traverseToTargetKeypoint(edgeId, sourceKeypoint, targetKeypointId, scoresBuffer, offsets, outputStride, displacements) {\n    var _a = scoresBuffer.shape,\n        height = _a[0],\n        width = _a[1];\n    var sourceKeypointIndices = getStridedIndexNearPoint(sourceKeypoint.position, outputStride, height, width);\n    var displacement = getDisplacement(edgeId, sourceKeypointIndices, displacements);\n    var displacedPoint = (0, _util.addVectors)(sourceKeypoint.position, displacement);\n    var displacedPointIndices = getStridedIndexNearPoint(displacedPoint, outputStride, height, width);\n    var offsetPoint = (0, _util.getOffsetPoint)(displacedPointIndices.y, displacedPointIndices.x, targetKeypointId, offsets);\n    var score = scoresBuffer.get(displacedPointIndices.y, displacedPointIndices.x, targetKeypointId);\n    var targetKeypoint = (0, _util.addVectors)({\n        x: displacedPointIndices.x * outputStride,\n        y: displacedPointIndices.y * outputStride\n    }, { x: offsetPoint.x, y: offsetPoint.y });\n    return { position: targetKeypoint, part: _keypoints.partNames[targetKeypointId], score: score };\n}\nfunction decodePose(root, scores, offsets, outputStride, displacementsFwd, displacementsBwd) {\n    var numParts = scores.shape[2];\n    var numEdges = parentToChildEdges.length;\n    var instanceKeypoints = new Array(numParts);\n    var rootPart = root.part,\n        rootScore = root.score;\n    var rootPoint = (0, _util.getImageCoords)(rootPart, outputStride, offsets);\n    instanceKeypoints[rootPart.id] = {\n        score: rootScore,\n        part: _keypoints.partNames[rootPart.id],\n        position: rootPoint\n    };\n    for (var edge = numEdges - 1; edge >= 0; --edge) {\n        var sourceKeypointId = parentToChildEdges[edge];\n        var targetKeypointId = childToParentEdges[edge];\n        if (instanceKeypoints[sourceKeypointId] && !instanceKeypoints[targetKeypointId]) {\n            instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint(edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores, offsets, outputStride, displacementsBwd);\n        }\n    }\n    for (var edge = 0; edge < numEdges; ++edge) {\n        var sourceKeypointId = childToParentEdges[edge];\n        var targetKeypointId = parentToChildEdges[edge];\n        if (instanceKeypoints[sourceKeypointId] && !instanceKeypoints[targetKeypointId]) {\n            instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint(edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores, offsets, outputStride, displacementsFwd);\n        }\n    }\n    return instanceKeypoints;\n}\n//# sourceMappingURL=decodePose.js.map"},"hash":"70d544fe3f3b473bb7f15b2db5d48b31","cacheData":{"env":{}}}