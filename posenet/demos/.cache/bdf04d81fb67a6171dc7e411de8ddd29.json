{"dependencies":[{"name":"/Users/Shoshana/Documents/Active/2018/Coding_Bootcamp/SeniorPhase/tfjs-models/posenet/demos/package.json","includedInParent":true,"mtime":1533242702575},{"name":"/Users/Shoshana/Documents/Active/2018/Coding_Bootcamp/SeniorPhase/tfjs-models/posenet/demos/.babelrc","includedInParent":true,"mtime":1533242702523},{"name":"/Users/Shoshana/Documents/Active/2018/Coding_Bootcamp/SeniorPhase/tfjs-models/posenet/demos/node_modules/@tensorflow-models/posenet/package.json","includedInParent":true,"mtime":1533242740778},{"name":"@tensorflow/tfjs","loc":{"line":1,"column":20}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.MobileNet = exports.mobileNetArchitectures = undefined;\nexports.assertValidOutputStride = assertValidOutputStride;\nexports.assertValidResolution = assertValidResolution;\nexports.assertValidScaleFactor = assertValidScaleFactor;\n\nvar _tfjs = require('@tensorflow/tfjs');\n\nvar tf = _interopRequireWildcard(_tfjs);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar mobileNet100Architecture = [['conv2d', 2], ['separableConv', 1], ['separableConv', 2], ['separableConv', 1], ['separableConv', 2], ['separableConv', 1], ['separableConv', 2], ['separableConv', 1], ['separableConv', 1], ['separableConv', 1], ['separableConv', 1], ['separableConv', 1], ['separableConv', 2], ['separableConv', 1]];\nvar mobileNet75Architecture = [['conv2d', 2], ['separableConv', 1], ['separableConv', 2], ['separableConv', 1], ['separableConv', 2], ['separableConv', 1], ['separableConv', 2], ['separableConv', 1], ['separableConv', 1], ['separableConv', 1], ['separableConv', 1], ['separableConv', 1], ['separableConv', 1], ['separableConv', 1]];\nvar mobileNet50Architecture = [['conv2d', 2], ['separableConv', 1], ['separableConv', 2], ['separableConv', 1], ['separableConv', 2], ['separableConv', 1], ['separableConv', 2], ['separableConv', 1], ['separableConv', 1], ['separableConv', 1], ['separableConv', 1], ['separableConv', 1], ['separableConv', 1], ['separableConv', 1]];\nvar VALID_OUTPUT_STRIDES = [8, 16, 32];\nfunction assertValidOutputStride(outputStride) {\n    tf.util.assert(typeof outputStride === 'number', 'outputStride is not a number');\n    tf.util.assert(VALID_OUTPUT_STRIDES.indexOf(outputStride) >= 0, \"outputStride of \" + outputStride + \" is invalid. \" + \"It must be either 8, 16, or 32\");\n}\nfunction assertValidResolution(resolution, outputStride) {\n    tf.util.assert(typeof resolution === 'number', 'resolution is not a number');\n    tf.util.assert((resolution - 1) % outputStride === 0, \"resolution of \" + resolution + \" is invalid for output stride \" + (outputStride + \".\"));\n}\nfunction assertValidScaleFactor(imageScaleFactor) {\n    tf.util.assert(typeof imageScaleFactor === 'number', 'imageScaleFactor is not a number');\n    tf.util.assert(imageScaleFactor >= 0.2 && imageScaleFactor <= 1.0, 'imageScaleFactor must be between 0.2 and 1.0');\n}\nvar mobileNetArchitectures = exports.mobileNetArchitectures = {\n    100: mobileNet100Architecture,\n    75: mobileNet75Architecture,\n    50: mobileNet50Architecture\n};\nfunction toOutputStridedLayers(convolutionDefinition, outputStride) {\n    var currentStride = 1;\n    var rate = 1;\n    return convolutionDefinition.map(function (_a, blockId) {\n        var convType = _a[0],\n            stride = _a[1];\n        var layerStride, layerRate;\n        if (currentStride === outputStride) {\n            layerStride = 1;\n            layerRate = rate;\n            rate *= stride;\n        } else {\n            layerStride = stride;\n            layerRate = 1;\n            currentStride *= stride;\n        }\n        return {\n            blockId: blockId,\n            convType: convType,\n            stride: layerStride,\n            rate: layerRate,\n            outputStride: currentStride\n        };\n    });\n}\nvar MobileNet = function () {\n    function MobileNet(variables, convolutionDefinitions) {\n        this.PREPROCESS_DIVISOR = tf.scalar(255.0 / 2);\n        this.ONE = tf.scalar(1);\n        this.variables = variables;\n        this.convolutionDefinitions = convolutionDefinitions;\n    }\n    MobileNet.prototype.predict = function (input, outputStride) {\n        var _this = this;\n        var preprocessedInput = tf.cast(input, 'float32').div(this.PREPROCESS_DIVISOR).sub(this.ONE);\n        var layers = toOutputStridedLayers(this.convolutionDefinitions, outputStride);\n        return layers.reduce(function (previousLayer, _a) {\n            var blockId = _a.blockId,\n                stride = _a.stride,\n                convType = _a.convType,\n                rate = _a.rate;\n            if (convType === 'conv2d') {\n                return _this.conv(previousLayer, stride, blockId);\n            } else if (convType === 'separableConv') {\n                return _this.separableConv(previousLayer, stride, blockId, rate);\n            } else {\n                throw Error(\"Unknown conv type of \" + convType);\n            }\n        }, preprocessedInput);\n    };\n    MobileNet.prototype.convToOutput = function (mobileNetOutput, outputLayerName) {\n        return mobileNetOutput.conv2d(this.weights(outputLayerName), 1, 'same').add(this.biases(outputLayerName));\n    };\n    MobileNet.prototype.conv = function (inputs, stride, blockId) {\n        return inputs.conv2d(this.weights(\"Conv2d_\" + String(blockId)), stride, 'same').add(this.biases(\"Conv2d_\" + String(blockId))).clipByValue(0, 6);\n    };\n    MobileNet.prototype.separableConv = function (inputs, stride, blockID, dilations) {\n        if (dilations === void 0) {\n            dilations = 1;\n        }\n        var dwLayer = \"Conv2d_\" + String(blockID) + \"_depthwise\";\n        var pwLayer = \"Conv2d_\" + String(blockID) + \"_pointwise\";\n        var x1 = inputs.depthwiseConv2D(this.depthwiseWeights(dwLayer), stride, 'same', 'NHWC', dilations).add(this.biases(dwLayer)).clipByValue(0, 6);\n        var x2 = x1.conv2d(this.weights(pwLayer), [1, 1], 'same').add(this.biases(pwLayer)).clipByValue(0, 6);\n        return x2;\n    };\n    MobileNet.prototype.weights = function (layerName) {\n        return this.variables[\"MobilenetV1/\" + layerName + \"/weights\"];\n    };\n    MobileNet.prototype.biases = function (layerName) {\n        return this.variables[\"MobilenetV1/\" + layerName + \"/biases\"];\n    };\n    MobileNet.prototype.depthwiseWeights = function (layerName) {\n        return this.variables[\"MobilenetV1/\" + layerName + \"/depthwise_weights\"];\n    };\n    MobileNet.prototype.dispose = function () {\n        for (var varName in this.variables) {\n            this.variables[varName].dispose();\n        }\n    };\n    return MobileNet;\n}();\nexports.MobileNet = MobileNet;\n//# sourceMappingURL=mobilenet.js.map"},"hash":"a9e05865d286dff1c3ca8d26368fbc85","cacheData":{"env":{}}}